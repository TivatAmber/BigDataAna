## 实验过程
### 编程思路
#### Apriori
1. 初始化
    - 读取数据集，将单词编号，并建立一对一映射
    - 从数据集中扫描所有单个项，构建候选 1 项集
    - 从每个项集进行扫描，计算其支持度，选出支持度大于或等于最小支持度阈值的项集，形成频繁 1 项对。
2. 迭代生成频繁项集
    - 利用频繁 k-1 项集生成候选 k 项集
    - 对每个候选 k 项集进行扫描计算其支持度，选出支持度大于或等于最小支持阈值的项集，形成频繁 k 项集。
    - 重复上述步骤直到不能生成新的频繁项集。
3. 生成关联规则
    - 对每个频繁项集，生成所有可能的关联规则。
    - 计算每条关联规则的置信度，选出置信度大于或等于最小置信度阈值的规则。

#### PCY
1. 初始化
    - 读取数据集，将单词编号，并建立一对一映射
    - 从数据集中扫描所有单个项，构建候选 1 项集
    - 从每个项集进行扫描，计算其支持度，选出支持度大于或等于最小支持度阈值的项集，形成拼房 1 项对。
2. 生成频繁项集
    - 利用频繁 1 项集和哈希通生成候选 2 项集，并对每个候选 2 项集合进行扫描，计算其支持度，选出支持度大于或等于最小支持度阈值的项集，形成频繁 2 项集
    - 迭代生成更高阶的候选项集和频繁项集，直到无法生成新的频繁项集为止。
3. 生成关联规则
    - 对每个频项集，生成所有可能的关联规则。
    - 计算每条关联规则的置信度，选出置信度大于或等于最小置信度阈值的规则。
### 遇到的问题及解决方法
1. 枚举长度为 k+1 的集合，直接通过全集枚举消耗时间过长   
**解决方法**：直接通过将长度为 k 的候选集排序之后，选择前 k-1 个，和另一个长度为 k 的候选集排序后的前 k-1 个做比较。如果元素相同，那么就合并两个候选集   
由于候选集一定两两不相同，那么我们就可以得到长度为 k+1 的候选集。
2. 在 PCY 算法中，需要使用哈希函数来获取映射值，但是通过相加获取哈希值的映射值太少，导致大多数桶中元素过多，大多数桶都是频繁桶   
**解决方法**：通过更换哈希函数，将其映射到更大范围内，由于新的哈希函数结果分布不均，那么使用素数作为桶个数，这样可以有效减少哈希冲突，使得频繁桶数量相对更少，提高算法运行速度。   
如果采用分布均匀的哈希函数，那么可以不用考虑使用素数。同时，应当注意不要讲桶个数设置太少，会导致频繁桶数量增加，算法运行速度变慢。

### 实验测试与结果分析
数据集较小时，Apriori 算法比 PCY 算法运行时间更短    
笔者猜测有如下原因
1. 哈希桶和哈希函数计算带来了额外的开销，桶计数频繁更新   
在第一次扫描时，哈希函数的计算和频繁的内存操作会导致计算量的增加，同时需要保证哈希函数对顺序不同的集合算出来结果一致，增加了计算量，所以在小规模数据中，PCY 算法的优势体现并不明显。
2. PCY 在筛选时，并没有去掉更多的的非频繁项对   
在小规模数据中，候选集的数量相对较少，在使用 Apriori 算法进行候选项集生成和频繁项对筛选的效率已经足够，PCY 算法的哈希过滤机制在这种情况下不能显著减少候选项集的数量。
3. PCY 算法本身是针对大规模数据进行的优化，在小规模数据上体现不显著   
PCY 算法设计的初衷是为了利用多余的内存，解决大规模数据集上的计算效率问题，对于小规模数据集本身计算量不大，因此优化效果不显著，甚至会增加计算时间。

### 实验总结
